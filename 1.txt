——————————分析

————离散事件以及系统仿真的介绍以及步骤

——离散事件
1. 离散事件模拟的基本概念
离散事件模拟的核心思想是模拟系统在离散的时间点上发生的事件，这些事件会引起系统状态的变化。模拟系统中的事件可以是各种类型的，比如到达事件、服务事件、离开事件等。模拟通过在时间上推进，模拟系统在不同事件发生时的状态变化，从而得出系统的性能指标、行为和结果。

2. 离散事件模拟的基本步骤
离散事件模拟算法通常包含以下基本步骤：
    2.1. 问题定义和模型建立： 确定模拟的系统范围和目标，选择适当的模型来表示系统中的各个组成部分和它们之间的交互关系。建立模型需要考虑系统中的实体、事件、资源、状态等元素。
    2.2. 初始化： 设置模拟的起始条件，包括系统状态、实体的初始状态、资源的可用性等。
    2.3. 事件生成： 根据模型中设定的规则，生成即将发生的事件。这些事件可能是系统中实体到达某个地点、资源可用等。
    2.4. 事件排序： 将生成的事件按照发生时间进行排序，以确保在模拟中按时间顺序进行处理。
    2.5. 事件处理： 处理排序后的事件，根据事件类型和规则更新系统状态，可能会触发其他事件的生成。比如，处理一个到达事件可能会触发一个服务事件。
    2.6. 数据收集和统计： 在模拟过程中，收集和记录所需的性能指标，如等待时间、资源利用率、系统吞吐量等。
    2.7. 模拟终止条件： 设定模拟的终止条件，可以是达到一定的模拟时间、处理一定数量的事件等。

——系统仿真
    系统仿真（system simulation）就是根据系统分析的目的，在分析系统各要素性质及其相互关系的基础上，建立能描述系统结构或行为过程的、且具有一定逻辑关系或数量关系的仿真模型，据此进行试验或定量分析，以获得正确决策所需的各种信息。
    即：
    * 分析对象为整个系统表现出来的宏观属性；
    * 基于宏观的物理参数（集总参数）和物理元器件的数学方程描述宏观物理属性和现象；
    * 多科学多层次的建模方法，与FEA、MBS、CFD等基于3D模型的分析方法不同；
    * 系统模型由组成该系统的物理元件模型组成，通过元件数学方程和代码的组装，可以自动形成整个系统的方程；
    * 分析类型和计算结果主要是稳态、动态时域或频域响应等。



经过仔细阅读题目后，对整个项目进行分析，初步确定整个项目需要三个类——顾客，理发师，理发馆
    ———初始准备
   对于整个项目的结构，首先将项目的主题放在同一个命名空间中namespace myBarberShop,将本项目所需的所有类分别定义在不同的头文件中即Customer.h,Barber.h, BarberShop.h
   同时创建一个headerFiles.h，将所有不同文件都可能用到的结构体，常量，而枚举类型等通用定义放在其中,如：
     using Rank = unsigned int;（使用Rank代表无符号整型数据，在需要使用到整型数据且不会出现负数的时候可以规避错误，相当于assert: number >= 0）
   将分钟作为单位时间
   ————进一步分析
   通读设计要求，确定各类所需的数据成员，成员函数以及可能用到的常量等。
   1.顾客类
     (1)数据成员
        1）为了在模拟过程中的便捷性，我们需要定义顾客ID：Rank customerId；
        2）服务选项selection select,其类型selection为一个结构体（内部成员为headerFiles定义的理发师等级barberLevel， 其构造函数内部实现——随机生成选择的理发师等级）；
        3) 到达时间：Rank arrivalTime,便于获取等待时间完成设计要求；
        4）进门顾客理发所需服务时间（简称：理发时间）：Rank durTime。
     (2)成员函数
        获得顾客本次服务所需的所有费用，实现方法——直接返回服务时间与不同等级理发师收费标准（元/分钟）的乘积，

        注意：将顾客类设置为struct或者将其所有内部成员设置为public，因为作为一名顾客，其需求（选择的理发师等级，所需的服务时间和进门时间）以及编号（第几个进的理发馆）都应该显式的声明。
   2.理发师类
     (1)数据成员
        1）理发师的编号：Rank id，便于在模拟过程理发师vector与顾客queue进行交互；
        2）理发师的等级：barberLevel level;
        3) 理发师的空闲状态：bool isFree，用于在模拟过程中判断该名理发师是否空闲，使得顾客能够优先选择；
        4）理发师的总收入：double totalRevenue, 在模拟过程中同步更新，使得设计要求中的“统计每天不同级别理发师的创收”能够直观的通过判断等级而获取；
        5）理发师的队列长度：Rank size，便于在模拟过程中实时获取该理发师的队列长度，以及在寻找空闲理发师未果，能够快速通过比较其大小从而挑选最短队列的理发师。
     (2)成员函数
        1）理发：即实时判断理发馆中的理发椅是否有空。
          内部实现——遍历椅子状态数组（定义在headerFiles中，类型为chairStatus（枚举类型，其中包含OCCUPIED, UNOCCUPIED状态），初始化为UNOCCUPIED）,当理发师选择使用该秩的理发椅时，将其状态变为OCCUPIED;

   3.理发馆类
     (1)数据成员
        1）营业时间:Rank serviceTime,在构造函数中初始化为DEFAULT_SERVICE_TIME = 14*60，即为14小时；
        2）理发师数组:vector<barber> barbers;
        3) 顾客队列:vector<queue<Customer>> customers;将vector作为外部数据结构是为了和理发师数组相对应，从而便于获取理发师的等待队列；
     (2)成员函数
        1）首先在构造函数中，在初始化列表中使用barbers(DEFAULT_BARBERS)来将barbers的大小初始化为默认理发师的数量。紧接着，采用文件流的方式，利用C++中fstream库的ifstream打开文件进行读，通过在文件中每一行输入理发师的编号以及理发师的等级，
        在构造函数中对理发师数组进行初始化，同时注意：需将customers.resize(DEFAULT_BARBERS)，否则会在访问customers队列时出错。另外显式声明构造函数，其参数为理发师的数量，从而在实例化时，通过显式传参来初始化barbers;
        2) 显示函数void display()——同样使用C++的fstream库，使用ofstream对象，采用文本方式（横向显示每张椅编号、理发师级别。纵向表示等待该理发师理发的排队长度）；
        3）总收入函数：double totalRevenue()——通过遍历理发师数组，获取每个理发师的数据成员totalRevenue,进行加和，从而获取模拟过程后的总收入
        4）不同等级理发师的收入函数：void levelRevenue()——同样遍历理发师数组，通过判断理发师的等级将理发师分类。从而对不同等级的能够分别加和其totalRevenue，以此获取不同等级理发师的收入；
        5）更换状态函数：inline void updateStatus()——用于在模拟过程实时更新理发师的空闲状态；
        6）模拟函数：void simulate()——开始模拟一天的流程，所有用到的函数都将在此函数中调用，即为真正的主函数。
        7）将顾客信息写入文件的函数：static void writeArrivalTime(const Customer& customer)——通过传参customer以及ofstream对象将顾客的所有信息写入文件。
        其中与其他文件函数不同点在于，打开文件时需要open(..., ios::out | ios::app)，使得能够在空行进行书写，否则后续顾客信息会覆盖前一个顾客的信息

——————————模拟
设计要求：
a) 一天内顾客在理发馆内的平均逗留时间；
b) 顾客排队等候理发的队列长度平均值；
c) 营业时间到点后仍需完成服务的收尾工作时间；
d) 统计每天的营业额；
e) 统计每天不同级别理发师的创收。

根据以上设计要求，我们明确模拟一天的过程需要得到数据有：
（1）当前时间（currentTime），从而能够模拟一天的时间流速
（2）一天内进入理发馆的顾客总人数（totalCustomers）；
（3）所有顾客在理发馆的平均逗留时间——其中包括顾客所需的服务时间（durTime）以及当选择的理发师正在理发中而在其等待队列的等待时间；
（4）每次进入顾客后，待其选择完理发师后，此时所有理发师的等待队列的长度的之和；
（5）当当前时间到达打烊时间后，还在等待队列中的顾客所需的服务时间以及此时还正在服务的顾客的服务剩余时间；
（6）每个理发师的收入；
（7）总的营业额；

具体模拟过程：
（1）首先在总的循环过程恩外，将需要的数据先定义出来，并且先初始化为0：
            //总收入
            double totalEarnings = 0;
            //当前时间
            Rank currentTime = 0;
            //顾客序号
            Rank customer_id = 0;
            //总逗留时间
            Rank customerTotalLastingTime = 0;
            //顾客总数
            Rank totalCustomers = 0;
            //总收尾工作时间
            Rank totalEndingTime = 0;
            //等待队列长度
            Rank queueTotalLength = 0;
（2）正式进入主循环模拟过程，能够进入循环的判断条件为currentTime < myBarberShop::DEFAULT_SERVICE_TIME(默认服务时间，可以修改)
    首先，使用C++的random库生成随机数，为提高复用性以及通用性，将生成随机数的过程封装成一个函数 Rank generateRandomNumber(Rank start, Rank end)以及 barberLevel randomBarberLevel()，
    第一个函数随机生成[start, end]之间的数，第二个函数随机生成理发师的等级（理发师的等级定义为一个枚举类型，其中从第一等级到第三等级分别对应integer 1-3）,从而满足设计要求中——每个顾客进门时将生成三个随机数:
       1） durtime:进门顾客理发所需服务时间（简称：理发时间）；
       2) intertime:下一顾客将到达的时间间隔（简称：间隔时间）；
       3) select:服务选项 ；
    生成以上随机数后，便可以实例化一个新顾客——Customer customer(...);
    其中构造函数传参为:顾客序号为customer_id++, 服务选项，到达时间为currentTime+internalTime以及服务时间。

 （3）判断顾客进门时间是否在打烊时间之前，如果已经超过打烊时间，那么直接退出循环，否则：
    1.先将该名顾客的信息写入文件，便于调试以及检验结果的正确性;
    2.寻找空闲的理发师。此处定义一个布尔类型assigned用来表征是否找到，如果找到了空闲的理发师，则将assigned赋值为true;
    3.如果没找到空闲的理发师，即assigned == false，那么需要找到所有符合顾客需求等级的理发师中最短等待队列进入，并将totalCustomers++,currentTime += internal时间，进行更新时间；
    4.实现设计要求，更新等待队列长度，逗留时间以及收尾工作时间：
    遍历理发师数组，
       1）总逗留时间customerTotalLastingTime：其值为每个顾客所需的服务时间加上等待时间（如果等待）的总和再除以顾客总数。
       首先先定义一个加和sum，其值为所有顾客所需服务时间的总和，在顾客初始化到时候就可以更新；接着在遍历过程中，
       如果当前理发师的等待队列不为空，则遍历其等待队列，需要在headerFiles中开一个全局数组，用于记录模拟过程中每次循环所有isFree == false的理发师的上一位（或正在理发的）顾客的离开时间
       以此方便计算总的等待时间，每一个等待队列的顾客的等待时间为：同一名理发师的上一位顾客的离开时间 - 处于等待队列的顾客的到达时间；
       2) 队列平均长度：按照组内讨论理解，决定以模拟过程中各循环次数时的队列长度加和，在除以总人数，作为队列平均长度的结果
       即在每次加入新顾客后，加和此时所有理发师的等待队列size，最后退出循环后统计数据时除以顾客总数；
       3）收尾工作时间：退出循环后，即可计算收尾工作时间，重点：利用在headerFiles中定义的结束时间表
       当结束while循环后,通过查看顾客离开时间表，获取最后一轮循环时的顾客离开时间，这个时间减去时间即为收尾工作时间，最后加上人在等待队列的顾客的服务时间，得到最终的收尾工作时间；
       4）每天的营业额以及不同等级的理发师的创收：鉴于理发师类有数据成员totalRevenue,在每次加入新顾客时，均+=新顾客的服务时间*不同等级理发师的收费标准，故只需在结束while循环后，
       遍历理发师数组，通过分支判断，加和不同等级的理发师的创收和，而每天的营业额即为所有理发师的创收和。


————————图形化
     ————准备工作
     easyx库介绍：


————————————创新点